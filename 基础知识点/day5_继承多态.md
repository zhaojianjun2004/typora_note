### day5（对象数组和继承关系）

#### 一.对象数组

```java
类名[] 数组名=new 类名[数组长度]
```

 可以把对象根据索引放在对象数组里面

对象数组也可以作为参数

##### 2.static关键字

​	static可以修饰属性

> 类成员变量或静态成员变量使用static修饰的，作用范围在整个类的所有对象上，直接可以使用`类名.静态变量=初始化值 `，这样所有的类对象都会共享这一个初始化值
>
> 实例成员变量不用static修饰

​	static可以修饰方法

>类方法和静态方法使用static修饰，不能直接使用实例变量，不能调用实例方法（通过  `类名.方法名（）`访问）
>
>实例方法没有static修饰



###### 3.this关键字

​	this.方法名()   ：表示调用者使用方法（如果括号里有别的对象，这个this关键字是必不可少的）

```java
public void attack(Role role){
    System.out.println(this.getName()+"..."+role.getName())
}//这个this指代当前调用方法的对象，role表示参数对象
```

​	this.属性名：区分全局属性和局部属性

​	this([参数])：方法之间调用



###### 4.使用访问修饰符实现封装

​	4.1 包

​		4.1.1package进行打包操作URL地址反向写法

> 包可以避免命名冲突
>
> 包可以按功能对类进行组合
>
> 包可以保护类、数据和方法

​	打包语句必须在代码的第一条语句

​		4.1.2导包操作

​	类不在同一个包，就需要进行导包操作

​	`	静态导包：import static 包名`

​	4.2代码封装

​	属性和方法的访问修饰符

​	public

​    private （除了同类都不能调用）   

​	default（只能在当前包里访问）（不使用访问修饰符关键字来声明，表示默认）

​    protected(不是通用，可以在同包同类和子类调用)





#### 二.继承关系

##### 1.继承使用时机：

当类与类之间，存在相同（共性）的内容，并满足子类是父类的一种，就可以考虑使用继承，优化代码

2.java类是单继承(不支持继承多个父类)

```java
[public] class 子类 extends 父类{}
```

父类（基类、超类），子类（派生类）

3.父类方法和属性的继承和访问

> 父类私有的属性在子类不能直接使用，需要使用getter和setter方式访问
>
> 父类默认的属性在不同包下 不能访问
>
> 父类受保护和共有的方法和属性，在不同包下也可以访问

4.方法重写

 方法名、参数列表必须相同，父类方法不能私有，返回值类型小于等于父类方法返回值类型

(不能重写静态方法)

> 方法重写一般是相同的目标不同的实现方式
>
> ```java
> //求图形面积
> //都要一个共同的父类Graphics,且初始化方法calcArea()
> public class Rect extends Graphics{
> 	public void calcArea(){
>     	int area=length*width;
>     	System.out,println(area)
> 	}
> }
> public class Circle extends Graphics{
>     public void calcArea(){
>         double d=Math.PI*r*r;
>         System.out.println(area)
>     }
> }
> ```
>
> 子类中重写的方法上面建议加上@override注解，可以检验重写是否正确，可读性好

5.继承中成员变量和成员方法的访问特点：

​	首先在 局部变量找  ->本类成员变量找（this） ->父类成员变量(super) ，

> 方法重名就加this或super



1.抽象方法和抽象类

​	抽象方法：static关键字修饰，只有方法的声明，没有方法体；

​					不能是静态方法

​	抽象类：static关键字修饰

​					如果一个类里面有抽象方法，那么必须是抽象类

​				抽象类不能实例化

<span style="color:red">方法重写的时候必须重写抽象方法，如果子类不重写父类的抽象方法，那么子类必须是抽象类，否则报错</span>

2.final关键字

​	*final不可以和 abstract 放一起对方法和类修饰*





#### 三.多态

1.定义方式

```
父类类型 对象名=new 子类类型();//向上转型
```

多态允许不同的子类对象被当作父类对象来使用，从而获得同一方法调用在不同子类对象上具有不同的行为

多态的实现依赖于继承和方法重写两个关键特性



2.不明确方法参数具体属于哪一个类，就将父类对象作为形参，然后要调用方法了，就可以使用具体的类了

（图书馆管理系统）当我们看到方法参数是一个类，就知道可以传递所有的子类对象（多态拓展性）

3.多态的弊端：不能调用子类的特有功能

> 调用成员方法的时候，编译看左边，运行看右边
>
> 在编译的时候首先看左边的父类里面有没有这个方法，否则直接报错

》》解决办法：向下转型

> > ```java
> > 子类类型 新对象名=（子类类型）父类引用
> > ```
> >
> > Animal a=new Dog();
> >
> > Cat c=(cat)a;
> >
> > 这个转类型也不能乱转，必须判断对象是否属于这个类（istanceof运算判断）



###### 4.里氏代换原则

父类出现的地方，子类一定可以出现

> 换句话说，就是子类在继承父类的同时，不能修改父类的原有行为，只能拓展父类的功能

子类出现的地方，父类不一定可以出现

**通俗理解：**

>子类能够完全替换掉它们的基类而没有异常
>
>例子：'狗'继承'动物'的基类，即可以在任何使用’动物‘的地方替换成’狗‘，并且还可以添加一些只有’狗‘才能做的事，如‘狗吠’



###### 5.instanceof运算符

判断一个对象是否属于某个类（或父类），返回boolean类型值

```java
public void ride(Horse horse){
    if(horse instanceof whiteHorse){
        System.out.println("...")
    }
    System.out.println("...");
    horse.run;
}
```



6.静态方法是否可重写

当子类声明为父类，那么调用的静态方法还是父类的静态方法，不能实现方法的覆盖

> abstract修饰的抽象方法必须重写

>构造方法、private、final、static不能重写



